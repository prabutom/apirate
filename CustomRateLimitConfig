public class CustomRateLimitConfig {

    private static final Logger log = LoggerFactory.getLogger(CustomRateLimitConfig.class);

    private final Map<String, Bucket> bucketMap = new ConcurrentHashMap<>();
    private final AntPathMatcher pathMatcher = new AntPathMatcher();

    public CustomRateLimitConfig(RateLimitConfigLoader loader){
        loader.getEndpointLimits().forEach((key, config) -> {
            String[] parts = key.split(":", 2);
            if (parts.length !=2) {
                log.error("Invalid key provided: {}",key);
                return;
            }

            String method = parts[0].trim();
            String pattern = parts[1].trim();

            Bandwidth minuteLimit = Bandwidth.classic(
                    config.getMinuteCapacity(),
                    Refill.greedy(config.getMinuteCapacity(), Duration.ofMinutes(config.getMinuteDuration()))
            );

            Bandwidth dailyLimit = Bandwidth.classic(config.getDailyCapacity(),
                    Refill.greedy(config.getDailyCapacity(), Duration.ofDays(1))
            );

            Bucket bucket = Bucket.builder()
                    .addLimit(minuteLimit)
                    .addLimit(dailyLimit)
                    .build();

            bucketMap.put(key, bucket);
            log.info("Bucket registered for endpoint '{}'", key);
        });
    }

    public Bucket resolveBucket(String method, String path){
        for (Map.Entry<String, Bucket> entry : bucketMap.entrySet()) {
            String[] parts = entry.getKey().split(":", 2);
            if  (parts.length != 2)
                continue;

            String configMethod = parts[0];
            String configPattern = parts[1];

            if (method.equalsIgnoreCase(configMethod) && pathMatcher.match(configPattern, path))
            {
                log.info("CustomRateLimitConfig: Bucket found for parts {}", entry.getKey());
                return entry.getValue();

            }
        }
        return null;
    }
